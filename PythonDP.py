# 파이썬 1463번 문제 
# n = int(input())

# dp = [0] * (n+1) # +1을 해주는 이유는 배열의 인덱스가 0부터 시작하므로 for문의 i를 이용한 dp[i]번쨰를 꺼낼때 순서가 맞지 않으므로 +1을 해주는 것 같다.

# for i in range(2, n+1):
#     dp[i] = dp[i-1] + 1

#     if i % 2 == 0:
#         dp[i] = min(dp[i], dp[i//2]+1)
#     if i % 3 == 0:
#         dp[i] = min(dp[i], dp[i//3] + 1)

# print(dp[n])

# -----------------------------------------------------------------------------------------------------

# 2748번 문제 피보나치수 2

# top down 방식 재귀함수가 필요하다. ✨ 순서가 그리 중요하지 않음, 구현 난이도 쉬움

#cache = [-1] * 91    # dp테이블을 -1일로 초기화 why? -> 피보나치 수열에서는 0과 같거나 큰수들이 들어 오기 때문에 -> 음수로 판별한다.(즉 음수면 구한적이 없는 녀석임을 알 수 있음.)
#cache[0] = 0         #  0과 1은 알수 있으니 초기화 해준다         
#cache[1] = 1         #  0과 1은 알수 있으니 초기화 해준다 

#cnt = 0  # 얼마나 재귀를 사용하는지 궁금해서

# def f(n) :        
#     global cnt  # 전역변수를 변경하려면 global을 사용해 줘야 된다
#     cnt = cnt + 1
#     if  cache[n] == -1 :
#         cache[n] = f( n - 1) + f( n - 2)
    
#     return cache[n]
#print(f(int(input())))
#print(f'cnt : {cnt}')

#bottom - up 방식      ✨순차적으로 구하기 때문에 순서가 중요하다, 구현 난이도 어려움
# n = int(input())
# cache = [-1] * 91    # dp테이블을 -1일로 초기화 why? -> 피보나치 수열에서는 0과 같거나 큰수들이 들어 오기 때문에 -> 음수로 판별한다.(즉 음수면 구한적이 없는 녀석임을 알 수 있음.)
# cache[0] = 0         #  0과 1은 알수 있으니 초기화 해준다         
# cache[1] = 1

# for i in range(2, n+1) :
#     cache[i] = cache[i-1] + cache[i-2]

# print(cache[n])


# -----------------------------------------------------------------------------------------------------

